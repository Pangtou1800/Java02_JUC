# 前置知识回顾： Java多线程 -- Thread

## 创建多线程的两种方式：Thread和Runnable

### Day01问题：

    1.谈谈你对程序、进程、线程的理解
        ·程序(program)
            为完成特定任务、用某种语言编写的一组指令的集合。
            也就是指一段静态的代码块，静态对象。
        ·进程(process)
            是程序的一次执行过程，或是正在运行的一个程序。
            是一个动态的过程：有它自身的产生、存在、消亡的过程（生命周期）。
        ·线程(thread)
            进程可进一步细化为线程，是一个程序内部的一条执行路径。

    2.代码完成继承Thread的方式创建分线程，并遍历100以内的自然数。

    3.代码完成实装Runnable的方式创建分线程，并遍历100以内的自然数。

    4.对比两种创建方式
        ·实装Runnable的方式可以避免单继承的局限。
        ·实装Runnable的方式可以更容易地实现线程间的资源共享。

    5.说说你对IDEA中Project和Module的理解
        在IDEA中:
            ·Project是项目整体，相当于Eclipse的Workspace
            ·Module是模块，相当于Eclipse的Project

---    

## 程序、进程、线程的理解

### 程序(Program)

    为完成特定任务、用某种语言编写的一组指令的集合。
    也就是指一段静态的代码块，静态对象。

### 进程(Process)

    是程序的一次执行过程，或是正在运行的一个程序。
    是一个动态的过程：有它自身的产生、存在、消亡的过程（生命周期）。

    ·程序是静态的，进程是动态的
    ·进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。

### 线程(Thread)

    进程可进一步细化为线程，是一个程序内部的一条执行路径。

    ·若一个进程同一时间并行执行多个线程，就是支持多线程的
    ·线程作为调度和执行的最小单位，每个线程拥有独立的运行栈和程序计数器(pc)，
     线程切换的开销相对较小
    ·一个进程中的多个线程共享相同的内存单元/内存地址空间：
        它们从同一个堆中分配对象，可以访问相同的变量的对象
    ·这就使得线程间通信更简便、高效。
    ·但是多个线程操作共享的资源可能会带来安全隐患。

---

## 并行与并发

### 单核CPU与多核CPU

    ·单核CPU其实是一种假的多线程，因为在任何一个时间单元内，都只能执行一个线程的任务。

    ·多核CPU才能更好地发挥多线程的效率。

    ·一个Java进程其实至少有三个线程：

        1. main()主线程
        2. gc()垃圾回收线程
        03. 异常处理线程 ※如果发生异常会影响主线程

### 并行与并发的理解

    并行：
        多个CPU同时执行多个任务。

    并发：
        一个CPU（采用时间片）同时执行多个任务。

---

## 创建多线程的两种方式

### 一、继承Thread类

    01. 创建一个继承于Thread类的子类
    02. 重写Thread类的run()()
    03. 创建Thread类的子类的对象
    04. 通过此对象调用Thread类的start()()

    两个问题：

    问题一：
        启动线程必须调用start()，不能直接调用run()
    问题二：
        再启动一个线程时，必须重新创建一个新的子类对象

### 二、实现Runnable接口的方式：

    01. 创建一个实现了Runnable接口的类
    02. 实现类实装Runnable的抽象方法run()()
    03. 创建实现类的对象
    04. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
    05. 通过Thread类的对象调用start()()

### 两种方式的对比：

* 开发中优先选择实现Runnable接口方式
* 原因：
    01. 实现的方式没有单继承性的局限
    02. 实现的方式更适合来处理多线程数据共享的情况

---

## Thread类的常用方法

    1. start():

        启动当前线程，调用当前线程的run()

    2. run():

        通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中

    3. currentThread():

        静态方法，返回执行当前代码的线程

    4. getName():

        获取线程的名字

    5. setName():

        设置线程的名字

    6. yield():

        释放当前CPU的执行权

    7. join():

        在线程A中调用线程B的join方法，此时线程A进入阻塞状态，
        直到线程B完全执行完毕，线程A才结束阻塞状态。

    8. stop():

        已过时。当执行此方法时，强制结束当前线程。

    9. sleep(long millitime):

        让当前线程“睡眠”指定的millitime毫秒。
        在指定的millitime毫秒时间内，当前线程是阻塞状态。

    10. isAlive(): 

        判断当前线程是否存活。

### 线程的优先级

    MAX_PIROTITY: 10
    MIN_PRIOTIRY: 1
    NORM_PRIOTIRY: 5

### 如何获取和设置当前线程的优先级

    getPriority():
        获取当前线程的优先级
    setPriority():
        设置当前线程的优先级

    说明：
        高优先级线程抢占低优先级线程CPU的执行权，但只是从概率上来讲比较高。
        并不意味着只有当高优先级的线程执行完成后低优先级的线程才会执行。

### 线程通信

    · wait()
    · notify()
    · notifyAll()

    注意：这三个方法定义在Object类中

### 补充：线程的分类

    Java中的线程分为两类：守护线程和用户线程

    ·它们几乎在每个方面都是相同的，唯一的区别是判断JVM何时离开。
    ·守护线程是用来服务用户现成的，通过在start()前调用
        thread.setDaemon(true)
     可以把一个用户线程变成一个守护线程。
    ·Java垃圾回收线程就是一个典型的守护线程。
    ·若JVM中都是守护线程，当前JVM将退出。

---

## 线程的生命周期

### Java语言Thread类及其子类的五种状态：

    新建、就绪、运行、阻塞、死亡

                ·resume() ※已过时   ·suspend()方法 ※已过时
                ·notify(All)()方法   ·wait()方法
                ·获取同步锁          ·等待同步锁
                ·join()结束          ·a中b.join() => a阻塞
                ·sleep()时间到       ·sleep()方法
                      -------阻塞 <------ 
                      |                 |
           start()    ↓  获取CPU执行权   |          ·run()执行结束
    新建 ----------> 就绪 --------------> 运行 -------------------------> 死亡
                        <--------------             ·调用stop()
                         ·失去CPU执行权         ·出现error/exception，
                           ·yield()                   且没有处理
# Java JUC

    JUC: java.util.concurrent

## Java JUC简介

## volatile 关键字-内存可见性

